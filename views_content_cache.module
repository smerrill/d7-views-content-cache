<?php
// $Id$

/**
 * @file
 *   Views content cache cache.
 */

/**
 * Implementation of hook_views_api().
 */
function views_content_cache_views_api() {
  return array(
    'api' => 2,
    'path' => drupal_get_path('module', 'views_content_cache') .'/views',
  );
}

/**
 * Implementation of hook_nodeapi().
 */
function views_content_cache_nodeapi(&$node, $op, $teaser, $page) {
  switch ($op) {
    case 'insert':
    case 'update':
    case 'delete':
    case 'delete revision':
      views_content_cache_update_set($node, 'node');
      break;
  }
}

/**
 * Implementation of hook_comment().
 */
function views_content_cache_comment(&$a1, $op) {
  switch ($op) {
    case 'insert':
    case 'update':
    case 'delete':
    case 'publish':
    case 'unpublish':
      if (!empty($a1['nid']) && ($node = node_load($a1['nid']))) {
        views_content_cache_update_set($a1, 'comment');
      }
      break;
  }
}

/**
 * Create one or more update records for the given object.
 *
 * @param object $object
 *   The object for which the update is occurring. Example: a $node object.
 * @param string $object_type
 *   A string identifier that other modules can use to identify the type of
 *   object passed to them. Example: 'node'.
 * @param int $timestamp
 *   A timestamp to use for the update record. Optional.
 *
 * @return boolean
 *   Returns TRUE if one or more update records were written. FALSE if none
 *   were written.
 */
function views_content_cache_update_set($object, $object_type, $timestamp = NULL) {
  $update = FALSE;
  $timestamp = isset($timestamp) ? $timestamp : time();
  if ($cids = views_content_cache_id_generate($object, $object_type)) {
    foreach ($cids as $cid) {
      if (!empty($cid)) {
        $update = TRUE;
        $mapped = views_content_cache_id_record($cid);

        // Remove any update records that match this cid.
        $where = array();
        $args = array();
        foreach ($mapped as $key_id => $key_value) {
          if (isset($key_value)) {
            $where[] = "{$key_id} = " . db_placeholders($key_value, 'varchar');
            $args[] = $key_value;
          }
          else {
            $where[] = "{$key_id} IS NULL";
          }
        }
        if (!empty($where)) {
          $where = implode(' AND ', $where);
          db_query("DELETE FROM {views_content_cache} WHERE {$where}", $args);
        }

        $mapped['timestamp'] = $timestamp;
        drupal_write_record('views_content_cache', $mapped);
      }
    }
  }
  return $update;
}

/**
 * Retrieve the latest update record for a given cache id.
 *
 * @param array $cid
 *   A cache id array. May contain multiple values for each key id.
 * @param boolean $reset
 *   Reset the internal static cache of timestamps for particular keys.
 *
 * @return int
 *   Returns the timestamp of the latest update record matching the given cache
 *   id or FALSE if none was found.
 */
function views_content_cache_update_get($cid, $reset = FALSE) {
  static $cache = array();
  $hash = md5(serialize($cid));
  if (!isset($cache[$hash]) || $reset) {
    $mapped = views_content_cache_id_record($cid);

    // Generate the where clause from the cache id.
    $where = array();
    $args = array();
    foreach ($mapped as $key_id => $key_value) {
      if (!empty($key_value)) {
        $where[] = "{$key_id} IN (" . db_placeholders($key_value, 'varchar') . ")";
        $args = array_merge($args, array_values($key_value));
      }
    }
    $where = implode(' AND ', $where);
    $cache[$hash] = db_result(db_query("SELECT timestamp FROM {views_content_cache} WHERE {$where} ORDER BY timestamp DESC", $args));
  }
  return $cache[$hash];
}

/**
 * Generate one or more cache ids for an update record.
 *
 * @param object $object
 *   The object for which the update is occurring. Example: a $node object.
 * @param string $object_type
 *   A string identifier that other modules can use to identify the type of
 *   object passed to them. Example: 'node'.
 *
 * @return array
 *   Returns an array of cache ids.
 */
function views_content_cache_id_generate($object, $object_type) {
  $cids = array(array());
  foreach (views_content_cache_get_plugin() as $key_id => $plugin) {
    $key_values = $plugin->content_key($object, $object_type);
    $key_values = is_array($key_values) ? $key_values : array($key_values);
    // If the content key is multivalue create an additional cid per value.
    $processed = array();
    foreach ($key_values as $key_value) {
      foreach ($cids as $cid) {
        $cid[$key_id] = $key_value;
        $processed[] = $cid;
      }
    }
    $cids = $processed;
  }
  return $cids;
}

/**
 * Convert a cache id to an update record suitable for drupal_write_record() or
 * use in a SELECT query.
 *
 * @param array $cid
 *   An array representing a cache id where keys correspond to plugin key IDs
 *   and values are the cache id values generated by each plugin.
 *
 * @return array
 *   An array where each plugin key ID has been replaced by one of the
 *   corresponding database columns c1 through c8.
 */
function views_content_cache_id_record($cid) {
  $map = views_content_cache_id_schema();
  $record = array();
  foreach ($cid as $key_id => $key_value) {
    if ($key_id === 'timestamp') {
      $record[$key_id] = $key_value;
    }
    else if (isset($map[$key_id]) && $column = $map[$key_id]) {
      $record[$column] = $key_value;
    }
  }
  return $record;
}

/**
 * Retrieve or generate the cache id to schema mapping.
 *
 * We store the schema mapping in the main cache table/bin, this means that it
 * can get invalidated quite quickly, but this will also probably coincide with
 * the views cache being flushed, so we're are just wasting a few CPU cycles in
 * reality. 
 *
 * @param boolean $reset
 *   Reset the static and DB cache for the schema mapping.
 *
 * @return array
 *   An array where each key is a plugin key ID and each value is the
 *   corresponding database column.
 */
function views_content_cache_id_schema($reset = FALSE) {
  static $map;
  if (!isset($map) || $reset) {
    $cache = cache_get('views_content_cache_id_schema');
    if (!$reset && !empty($cache->data)) {
      $map = $cache->data;
    }
    else {
      $cache_keys = array_keys(views_content_cache_get_plugin());
      $i = 1;
      foreach ($cache_keys as $key_id) {
        // Schema is limited to 8.
        if ($i > 8) {
          break;
        }
        $map[$key_id] = "c{$i}";
        $i++;
      }
      // If the newly generated map and the prior map do not match invalidate
      // all cache update records.
      if (empty($cache->data) || ($map != $cache->data)) {
        db_query("TRUNCATE {views_content_cache}");

        // This is probably too aggressive. @TODO: See if we can surgically
        // invalidate only views that use VCC.
        views_invalidate_cache();
      }
      cache_set('views_content_cache_id_schema', $map, 'cache');
    }
  }
  return $map;
}

/**
 * Retrieve a plugin object.
 *
 * @param string $plugin
 *   The name of the plugin class to retrieve. Optional.
 * @param boolean $reset
 *   Reset the static cache.
 *
 * @return mixed
 *   If a specific plugin class was requested an instance of that class is
 *   returned. Otherwise, an array of all plugins.
 */
function views_content_cache_get_plugin($plugin = NULL, $reset = FALSE) {
  static $cache;
  if (!isset($cache) || $reset) {
    ctools_include('plugins');
    $plugins = ctools_get_plugins('views_content_cache', 'plugins');

    // This ksort is critical. This ensures that our plugins are in consistent
    // order, especially important for views_content_cache_id_schema().
    ksort($plugins);

    foreach ($plugins as $key => $info) {
      if (empty($info['abstract']) && $class = ctools_plugin_get_class($info, 'handler')) {
        $cache[$key] = new $class();
      }
    }
  }
  if (isset($plugin)) {
    return isset($cache[$plugin]) ? $cache[$plugin] : FALSE;
  }
  return $cache;
}

/**
 * CTools plugins API hooks ===================================================
 */

/**
 * Implementation of hook_ctools_plugin_api().
 */
function views_content_cache_ctools_plugin_api($module, $api) {
  if ($module == 'views_content_cache' && $api == 'plugins') {
    return array('version' => 1);
  }
}

/**
 * Implementation of hook_ctools_plugin_plugins().
 */
function views_content_cache_ctools_plugin_plugins() {
  return array(
    'cache' => TRUE,
    'use hooks' => TRUE,
  );
}

/**
 * Implementation of hook_context_plugins().
 *
 * This is a ctools plugins hook.
 */
function views_content_cache_views_content_cache_plugins() {
  $plugins = array();
  $plugins['base'] = array(
    'abstract' => TRUE,
    'handler' => array(
      'path' => drupal_get_path('module', 'views_content_cache') . '/plugins',
      'file' => 'base.inc',
      'class' => 'views_content_cache_key',
    ),
  );
  $plugins['node'] = array(
    'title' => t('Node type'),
    'description' => t('Invalidates cache by node type'),
    'handler' => array(
      'path' => drupal_get_path('module', 'views_content_cache') . '/plugins',
      'file' => 'node.inc',
      'class' => 'views_content_cache_key_node',
      'parent' => 'base',
    ),
  );
  if (module_exists('comment')) {
    $plugins['comment'] = array(
      'title' => t('Comment'),
      'description' => t('Invalidates cache when comments are posted or updated'),
      'handler' => array(
        'path' => drupal_get_path('module', 'views_content_cache') . '/plugins',
        'file' => 'comment.inc',
        'class' => 'views_content_cache_key_comment',
        'parent' => 'base',
      ),
    );
  }
  if (module_exists('og')) {
    $plugins['og'] = array(
      'handler' => array(
        'path' => drupal_get_path('module', 'views_content_cache') . '/plugins',
        'file' => 'og.inc',
        'class' => 'views_content_cache_key_og',
        'parent' => 'base',
      ),
    );
  }
  return $plugins;
}
